{
  "version": 3,
  "sources": ["../../../../../../node_modules/tinyspy/dist/index.js"],
  "sourcesContent": ["var __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/utils.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\nfunction isType(type, value) {\n  return typeof value === type;\n}\n\n// src/spy.ts\nvar spies = /* @__PURE__ */ new Set();\nfunction spy(cb) {\n  assert(isType(\"function\", cb) || isType(\"undefined\", cb), \"cannot spy on a non-function value\");\n  let fn = function(...args) {\n    fn.called = true;\n    fn.callCount++;\n    fn.calls.push(args);\n    if (fn.next) {\n      let [type2, result2] = fn.next;\n      fn.results.push(fn.next);\n      fn.next = null;\n      if (type2 === \"ok\") {\n        return result2;\n      }\n      throw result2;\n    }\n    let result;\n    let type = \"ok\";\n    if (fn.impl) {\n      try {\n        result = fn.impl.apply(this, args);\n        type = \"ok\";\n      } catch (err) {\n        result = err;\n        type = \"error\";\n        fn.results.push([type, err]);\n        throw err;\n      }\n    }\n    let resultTuple = [type, result];\n    if (result && isType(\"object\", result) && isType(\"function\", result.then)) {\n      result = result.then((r) => resultTuple[1] = r).catch((e) => {\n        resultTuple[0] = \"error\";\n        resultTuple[1] = e;\n        throw e;\n      });\n    }\n    fn.results.push(resultTuple);\n    return result;\n  };\n  Object.defineProperty(fn, \"length\", { value: cb ? cb.length : 0 });\n  Object.defineProperty(fn, \"__isSpy\", { value: true });\n  Object.defineProperty(fn, \"returns\", {\n    get() {\n      return this.results.map(([, r]) => r);\n    }\n  });\n  Object.defineProperty(fn, \"name\", { value: cb ? cb.name || \"spy\" : \"spy\" });\n  const reset = () => {\n    fn.called = false;\n    fn.callCount = 0;\n    fn.results = [];\n    fn.calls = [];\n  };\n  reset();\n  fn.impl = cb;\n  fn.reset = reset;\n  fn.nextError = (error) => {\n    fn.next = [\"error\", error];\n    return fn;\n  };\n  fn.nextResult = (result) => {\n    fn.next = [\"ok\", result];\n    return fn;\n  };\n  return fn;\n}\n\n// src/spyOn.ts\nvar getDescriptor = (obj, method) => Object.getOwnPropertyDescriptor(obj, method);\nfunction spyOn(obj, methodName, mock) {\n  assert(!isType(\"undefined\", obj), \"spyOn could not find an object to spy upon\");\n  assert(isType(\"object\", obj) || isType(\"function\", obj), \"cannot spyOn on a primitive value\");\n  let getMeta = () => {\n    if (typeof methodName === \"string\") {\n      return [methodName, \"value\"];\n    }\n    if (\"getter\" in methodName) {\n      return [methodName.getter, \"get\"];\n    }\n    return [methodName.setter, \"set\"];\n  };\n  let [accessName, accessType] = getMeta();\n  let objDescriptor = getDescriptor(obj, accessName);\n  let proto = Object.getPrototypeOf(obj);\n  let protoDescriptor = proto && getDescriptor(proto, accessName);\n  let descriptor = objDescriptor || protoDescriptor;\n  assert(descriptor || accessName in obj, `${accessName} does not exist`);\n  let ssr = false;\n  if (accessType === \"value\" && descriptor && !descriptor.value && descriptor.get) {\n    accessType = \"get\";\n    ssr = true;\n    mock = descriptor.get();\n  }\n  let origin;\n  if (descriptor) {\n    origin = descriptor[accessType];\n  } else if (accessType !== \"value\") {\n    origin = () => obj[accessName];\n  } else {\n    origin = obj[accessName];\n  }\n  if (!mock)\n    mock = origin;\n  let fn = spy(mock);\n  let define = (cb) => {\n    let _a = descriptor || {\n      configurable: true,\n      writable: true\n    }, { value } = _a, desc = __objRest(_a, [\"value\"]);\n    if (accessType !== \"value\") {\n      delete desc.writable;\n    }\n    ;\n    desc[accessType] = cb;\n    Object.defineProperty(obj, accessName, desc);\n  };\n  let restore = () => define(origin);\n  fn.restore = restore;\n  fn.getOriginal = () => ssr ? origin() : origin;\n  fn.willCall = (newCb) => {\n    fn.impl = newCb;\n    return fn;\n  };\n  define(ssr ? () => fn : fn);\n  spies.add(fn);\n  return fn;\n}\n\n// src/restoreAll.ts\nfunction restoreAll() {\n  for (let fn of spies) {\n    fn.restore();\n  }\n  spies.clear();\n}\nexport {\n  restoreAll,\n  spies,\n  spy,\n  spyOn\n};\n"],
  "mappings": ";;;AAAA,IAAI,sBAAsB,OAAO;AACjC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,YAAY,CAAC,QAAQ,YAAY;AACnC,MAAI,SAAS,CAAC;AACd,WAAS,QAAQ;AACf,QAAI,aAAa,KAAK,QAAQ,IAAI,KAAK,QAAQ,QAAQ,IAAI,IAAI;AAC7D,aAAO,IAAI,IAAI,OAAO,IAAI;AAC9B,MAAI,UAAU,QAAQ;AACpB,aAAS,QAAQ,oBAAoB,MAAM,GAAG;AAC5C,UAAI,QAAQ,QAAQ,IAAI,IAAI,KAAK,aAAa,KAAK,QAAQ,IAAI;AAC7D,eAAO,IAAI,IAAI,OAAO,IAAI;AAAA,IAC9B;AACF,SAAO;AACT;AAGA,SAAS,OAAO,WAAW,SAAS;AAClC,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,OAAO;AAAA,EACzB;AACF;AACA,SAAS,OAAO,MAAM,OAAO;AAC3B,SAAO,OAAO,UAAU;AAC1B;AAGA,IAAI,QAAwB,oBAAI,IAAI;AACpC,SAAS,IAAI,IAAI;AACf,SAAO,OAAO,YAAY,EAAE,KAAK,OAAO,aAAa,EAAE,GAAG,oCAAoC;AAC9F,MAAI,KAAK,YAAY,MAAM;AACzB,OAAG,SAAS;AACZ,OAAG;AACH,OAAG,MAAM,KAAK,IAAI;AAClB,QAAI,GAAG,MAAM;AACX,UAAI,CAAC,OAAO,OAAO,IAAI,GAAG;AAC1B,SAAG,QAAQ,KAAK,GAAG,IAAI;AACvB,SAAG,OAAO;AACV,UAAI,UAAU,MAAM;AAClB,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AACA,QAAI;AACJ,QAAI,OAAO;AACX,QAAI,GAAG,MAAM;AACX,UAAI;AACF,iBAAS,GAAG,KAAK,MAAM,MAAM,IAAI;AACjC,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,iBAAS;AACT,eAAO;AACP,WAAG,QAAQ,KAAK,CAAC,MAAM,GAAG,CAAC;AAC3B,cAAM;AAAA,MACR;AAAA,IACF;AACA,QAAI,cAAc,CAAC,MAAM,MAAM;AAC/B,QAAI,UAAU,OAAO,UAAU,MAAM,KAAK,OAAO,YAAY,OAAO,IAAI,GAAG;AACzE,eAAS,OAAO,KAAK,CAAC,MAAM,YAAY,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM;AAC3D,oBAAY,CAAC,IAAI;AACjB,oBAAY,CAAC,IAAI;AACjB,cAAM;AAAA,MACR,CAAC;AAAA,IACH;AACA,OAAG,QAAQ,KAAK,WAAW;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,eAAe,IAAI,UAAU,EAAE,OAAO,KAAK,GAAG,SAAS,EAAE,CAAC;AACjE,SAAO,eAAe,IAAI,WAAW,EAAE,OAAO,KAAK,CAAC;AACpD,SAAO,eAAe,IAAI,WAAW;AAAA,IACnC,MAAM;AACJ,aAAO,KAAK,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC;AAAA,IACtC;AAAA,EACF,CAAC;AACD,SAAO,eAAe,IAAI,QAAQ,EAAE,OAAO,KAAK,GAAG,QAAQ,QAAQ,MAAM,CAAC;AAC1E,QAAM,QAAQ,MAAM;AAClB,OAAG,SAAS;AACZ,OAAG,YAAY;AACf,OAAG,UAAU,CAAC;AACd,OAAG,QAAQ,CAAC;AAAA,EACd;AACA,QAAM;AACN,KAAG,OAAO;AACV,KAAG,QAAQ;AACX,KAAG,YAAY,CAAC,UAAU;AACxB,OAAG,OAAO,CAAC,SAAS,KAAK;AACzB,WAAO;AAAA,EACT;AACA,KAAG,aAAa,CAAC,WAAW;AAC1B,OAAG,OAAO,CAAC,MAAM,MAAM;AACvB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,IAAI,gBAAgB,CAAC,KAAK,WAAW,OAAO,yBAAyB,KAAK,MAAM;AAChF,SAAS,MAAM,KAAK,YAAY,MAAM;AACpC,SAAO,CAAC,OAAO,aAAa,GAAG,GAAG,4CAA4C;AAC9E,SAAO,OAAO,UAAU,GAAG,KAAK,OAAO,YAAY,GAAG,GAAG,mCAAmC;AAC5F,MAAI,UAAU,MAAM;AAClB,QAAI,OAAO,eAAe,UAAU;AAClC,aAAO,CAAC,YAAY,OAAO;AAAA,IAC7B;AACA,QAAI,YAAY,YAAY;AAC1B,aAAO,CAAC,WAAW,QAAQ,KAAK;AAAA,IAClC;AACA,WAAO,CAAC,WAAW,QAAQ,KAAK;AAAA,EAClC;AACA,MAAI,CAAC,YAAY,UAAU,IAAI,QAAQ;AACvC,MAAI,gBAAgB,cAAc,KAAK,UAAU;AACjD,MAAI,QAAQ,OAAO,eAAe,GAAG;AACrC,MAAI,kBAAkB,SAAS,cAAc,OAAO,UAAU;AAC9D,MAAI,aAAa,iBAAiB;AAClC,SAAO,cAAc,cAAc,KAAK,GAAG,UAAU,iBAAiB;AACtE,MAAI,MAAM;AACV,MAAI,eAAe,WAAW,cAAc,CAAC,WAAW,SAAS,WAAW,KAAK;AAC/E,iBAAa;AACb,UAAM;AACN,WAAO,WAAW,IAAI;AAAA,EACxB;AACA,MAAI;AACJ,MAAI,YAAY;AACd,aAAS,WAAW,UAAU;AAAA,EAChC,WAAW,eAAe,SAAS;AACjC,aAAS,MAAM,IAAI,UAAU;AAAA,EAC/B,OAAO;AACL,aAAS,IAAI,UAAU;AAAA,EACzB;AACA,MAAI,CAAC;AACH,WAAO;AACT,MAAI,KAAK,IAAI,IAAI;AACjB,MAAI,SAAS,CAAC,OAAO;AACnB,QAAI,KAAK,cAAc;AAAA,MACrB,cAAc;AAAA,MACd,UAAU;AAAA,IACZ,GAAG,EAAE,MAAM,IAAI,IAAI,OAAO,UAAU,IAAI,CAAC,OAAO,CAAC;AACjD,QAAI,eAAe,SAAS;AAC1B,aAAO,KAAK;AAAA,IACd;AACA;AACA,SAAK,UAAU,IAAI;AACnB,WAAO,eAAe,KAAK,YAAY,IAAI;AAAA,EAC7C;AACA,MAAI,UAAU,MAAM,OAAO,MAAM;AACjC,KAAG,UAAU;AACb,KAAG,cAAc,MAAM,MAAM,OAAO,IAAI;AACxC,KAAG,WAAW,CAAC,UAAU;AACvB,OAAG,OAAO;AACV,WAAO;AAAA,EACT;AACA,SAAO,MAAM,MAAM,KAAK,EAAE;AAC1B,QAAM,IAAI,EAAE;AACZ,SAAO;AACT;AAGA,SAAS,aAAa;AACpB,WAAS,MAAM,OAAO;AACpB,OAAG,QAAQ;AAAA,EACb;AACA,QAAM,MAAM;AACd;",
  "names": []
}
